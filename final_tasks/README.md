## Final tasks
<details>
<summary>Калькулятор</summary>

[Решение](calculator.py)

### Ограничение времени
1 секунда
### Ограничение памяти
64Mb

Задание связано с обратной польской нотацией. Она используется для парсинга арифметических 
выражений. Еще её иногда называют постфиксной нотацией.

В постфиксной нотации операнды расположены перед знаками операций.

#### Пример 1:  
`3 4 +`  
будет равно 7, и означает 3 + 4

#### Пример 2:  
`12 5 /`  
Так как деление целочисленное, то в результате получим 2.

#### Пример 3:  
`10 2 4 * -`  
будет равно 2, и означает 10 - 2 * 4

Разберём последний пример подробнее:  
Знак * стоит сразу после чисел 2 и 4, значит к ним нужно применить операцию, которую 
этот знак обозначает, то есть перемножить эти два числа. В результате получим 8.

После этого выражение приобретёт вид:  
`10 8 -`  
Операцию «минус» нужно применить к двум идущим перед ней числам, то есть 10 и 8. 
В итоге получаем `2`.

Рассмотрим алгоритм более подробно. Для его реализации будем использовать стек.

Для вычисления значения выражения, записанного в обратной польской нотации, нужно 
считывать выражение слева направо и придерживаться следующих шагов:

* Обработка входного символа:
  - Если на вход подан операнд, он помещается на вершину стека. 
  - Если на вход подан знак операции, то эта операция выполняется над требуемым 
    количеством значений из стека, взятых в порядке добавления. Результат выполненной 
    операции помещается на вершину стека. 
* Если входной набор символов обработан не полностью, перейти к шагу 1.
* После полной обработки входного набора символов результат вычисления выражения 
  находится в вершине стека. Если в стеке осталось несколько чисел, то надо вывести 
  только верхний элемент.

**Замечание про отрицательные числа и деление:** в этой задаче под делением понимается 
математическое целочисленное деление. Это значит, что округление всегда происходит 
вниз. А именно: если `a / b = c, то b ⋅ c` – это наибольшее число, которое не превосходит 
`a` и одновременно делится без остатка на `b`.

Например, `-1 / 3 = -1`. Будьте осторожны, в C++, Java и go, например, деление чисел работает иначе.

### Формат ввода

В единственной строке дано выражение, записанное в обратной польской нотации. 
Числа и арифметические операции записаны через пробел.

На вход могут подаваться операции: +, -, *, / и числа, по модулю не превосходящие 10000.

Гарантируется, что значение промежуточных выражений в тестовых данных по модулю не больше 50000.

### Формат вывода

Выведите единственное число — значение выражения.

</details>


<details>
<summary>Циклы</summary>

[Решение](cycles.py)

### Ограничение времени
1 секунда
### Ограничение памяти
64Mb

Необходимо написать программу, которая определяет, есть ли цикл в связном списке.

На вход функция принимает голову списка, на выходе должна выдать True, если в списке 
содержится цикл, иначе — False.

Размер дополнительной памяти, к которой обращается функция, не должен превышать О(1). 

### Формат ввода

В этой задаче вам нужно реализовать только функцию с решением, считывать входные данные не нужно.
Функция должна принимать на вход голову связного списка.

Класс, представляющая узел списка выглядит так:
```class Node:  
    def __init__(self, value, next=None):  
        self.value = value  
        self.next = next  
    def __repr__(self):  
        return self.value
```
Ваша функция должна называться hasCycle. 

### Формат вывода

Функция должна возвращать булево значение 

</details>

<details>
<summary>Фотокопии</summary>

[Решение](photocopy.py)

### Ограничение времени
4.5 секунд
### Ограничение памяти
64Mb

Евлампия очень любит постить фотографии в инстаграм. Но она боится, что данные с 
сервера могут пропасть. Поэтому она приняла решения хранить все изображения также 
в Трешландских датацентрах в двух экземплярах.

Всего есть N датацентров, в каждом из которых можно разместить `fi ≥ 0` фотографий, 
где `i = 0..N-1`.

Но хранить две копии фотографии в одном датацентре ненадежно. Вдруг с ним что-нибудь 
случится. Поэтому так делать нельзя. Нужно определить, какое максимальное число фотографий 
Евлампия сможет сохранить.

### Формат ввода

В первой строке записано n - количество датацентров. Оно не превосходит 10000.

В следующей строке через пробел записаны n чисел - вместимости датацентров в штуках ф
отографий. Каждое из чисел не превосходит 10000.

### Формат вывода

Нужно вывести число, равное максимальному количеству фотографий, для которых можно 
хранить копии в этих датацентрах.

</details>

<details>
<summary>Поиск в сломанном массиве</summary>

[Решение](broken_array.py)

### Ограничение времени
0.07 секунд
### Ограничение памяти
64Mb

Алла ошиблась при копировании из одной структуры данных в другую. Она хранила 
массив чисел в кольцевом буфере. Массив был отсортирован по возрастанию, и в нём 
можно было найти элемент за логарифмическое время. Алла скопировала данные из кольцевого 
буфера в обычный массив, но сдвинула данные исходной отсортированной последовательности. 
Теперь массив не является отсортированным. Тем не менее, нужно обеспечить возможность 
находить в нем элемент за `O(n*log n)`.

Можно предполагать, что в массиве только уникальные элементы.

### Формат ввода

В первой строке записано число `n` –— длина массива.

Во второй строке записано положительное число `k` –— искомый элемент. 

`n` и `k` не превосходят `10 000`.

Далее в строку через пробел записано n натуральных чисел, каждое из которых не 
превосходит `10 000`.

### Формат вывода

Выведите индекс искомого элемента в массиве, если он найден (нумерация с нуля). Иначе выведите `-1`. 

</details>

<details>
<summary>Большое число</summary>

[Решение](big_number.py)

### Ограничение времени
0.1 секунда
### Ограничение памяти
64Mb

Вечером ребята решили поиграть в игру «Большое число».
Даны числа. Нужно определить, какое самое большое число можно из них составить. 

### Формат ввода

В первой строке записано n — количество чисел. Оно не превосходит `100`.
Во второй строке через пробел записаны n неотрицательных чисел, каждое из которых 
не превосходит `1000`. 

### Формат вывода

Нужно вывести самое большое число, которое можно составить из данных чисел. 

</details>

<details>
<summary>Большое число</summary>

[Решение](big_number.py)

### Ограничение времени
0.6 секунд
### Ограничение памяти
28Mb

Когда Кондратий узнал про алгоритм поразрядной сортировки, он объявил конкурс 
на самую быструю реализацию алгоритма. Вы тоже принимаете участи в этом конкурсе. Успехов! 

### Формат ввода

В первой строке задано `n` - длина массива неотрицательных целых чисел, каждое из 
которых не превосходит `100000`.
В следующей строке через пробел записаны `n` чисел. 

### Формат вывода

Выведите числа в отсортированном по неубыванию порядке.

</details>