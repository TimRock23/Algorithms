## Sorting

<details>
<summary>A. Пузырёк</summary>

[Решение](A.py)

### Ограничение времени
25 секунд
### Ограничение памяти
64Mb

Чтобы выбрать самый лучший алгоритм для решения задачи, Гоша продолжил изучать 
разные сортировки. На очереди [сортировка пузырьком](https://ru.wikipedia.org/wiki/Сортировка_пузырьком)

Её алгоритм следующий (сортируем по неубыванию):

1. На каждой итерации проходим по массиву, поочередно сравнивая пары соседних элементов. 
Если элемент на позиции i больше элемента на позиции i + 1, меняем их местами. После 
первой итерации самый большой элемент всплывёт в конце массива.
2. Проходим по массиву, выполняя указанные действия до тех пор, пока на очередной 
итерации не окажется, что обмены больше не нужны, то есть массив уже отсортирован.
3. После не более чем n – 1 итераций выполнение алгоритма заканчивается, так как на 
каждой итерации хотя бы один элемент оказывается на правильной позиции.
   
Помогите Гоше написать код алгоритма. 

### Формат ввода

В первой строке на вход подаётся натуральное число n — длина массива, 2 ≤ n ≤ 1000.
Во второй строке через пробел записано n целых чисел.
Каждое из чисел по модулю не превосходит 1000.

Обратите внимание, что считывать нужно только 2 строки: значение n и входной массив. 

### Формат вывода

После каждого прохода по массиву, на котором какие-то элементы меняются местами, 
выводите его промежуточное состояние.
Таким образом, если сортировка завершена за k меняющих массив итераций, то надо 
вывести k строк по n чисел в каждой — элементы массива после каждой из итераций.

Если массив был изначально отсортирован, то просто выведите его.

</details>

<details>
<summary>B. Сортировка вставками</summary>

[Решение](B.py)

### Ограничение времени
10 секунд
### Ограничение памяти
64Mb

Теперь Гоша взялся за сортировку вставками.

Алгоритм следующий: На i-том шаге мы делаем так, чтобы первые i элементов массива шли в 
возрастающем порядке.

1. На первом шаге ничего делать не нужно — один элемент и так "отсортирован".
2. На втором шаге нужно сделать так, чтобы два первых элемента были верно отсортированы. 
   То есть если второй элемент оказался меньше первого, их нужно поменять местами.
3. На i-том шаге мы знаем, что первые `i-1` элементов уже отсортированы. Ищем, куда нужно 
   вставить i-ый элемент.

Для этого, начиная с позиции `j = i - 1`, сравниваем текущий элемент с элементом на 
позиции j. Пока j+1-й элемент больше j-ого и `j > 0`, меняем элементы местами и 
уменьшаем счётчик j на 1. Таким образом, стоявший на позиции i элемент будет 
перемещаться к своей правильной позиции.

Помогите Гоше написать код.

### Формат ввода

В первой строке на вход подаётся число n — длина массива. n не превосходит 1000. 
Во второй строке через пробел записаны n чисел. Каждое из чисел по модулю не превосходит 1000. 

### Формат вывода

Нужно вывести через пробел числа в отсортированном по возрастанию порядке.

</details>

<details>
<summary>C. Эффективная быстрая сортировка</summary>

[Решение](C.py)

### Ограничение времени
2 секунды
### Ограничение памяти
64Mb

Тимофей решил организовать соревнование по спортивному программированию, чтобы 
найти талантливых стажёров. Задачи подобраны, участники зарегистрированы, тесты 
написаны. Осталось придумать, как в конце соревнования будет определяться победитель.

Каждый участник имеет уникальный логин. Когда соревнование закончится, к нему 
будут привязаны два показателя: количество решённых задач Pi и размер штрафа Fi. 
Штраф начисляется за неудачные попытки и время, затраченное на задачу.

Тимофей решил сортировать таблицу результатов следующим образом: при сравнении 
двух участников выше будет идти тот, у которого решено больше задач. При равенстве 
числа решённых задач первым идёт участник с меньшим штрафом. Если же и штрафы совпадают, 
то первым будет тот, у которого логин идёт раньше в алфавитном (лексикографическом) порядке.

Тимофей заказал толстовки для победителей и накануне поехал за ними в магазин. 
В своё отсутствие он поручил вам реализовать алгоритм быстрой сортировки (англ. 
quick sort) для таблицы результатов. Так как Тимофей любит спортивное программирование 
и не любит зря расходовать оперативную память, то ваша реализация сортировки не может 
потреблять O(n) дополнительной памяти для промежуточных данных (такая модификация 
быстрой сортировки называется "in-place"). 

### Формат ввода

В первой строке задано число участников n, 1 ≤ n ≤ 100 000.
В каждой из следующих n строк задана информация про одного из участников.
i-й участник описывается тремя параметрами:

- уникальным логином (строкой из маленьких латинских букв длиной не более 20)
- числом решённых задач Pi
- штрафом Fi

Fi и Pi — целые числа, лежащие в диапазоне от 0 до 109. 

### Формат вывода

Для отсортированного списка участников выведите по порядку их логины по одному в строке.

</details>

<details>
<summary>D. Тараканьи бега</summary>

[Решение](D.py)

### Ограничение времени
1 секунда
### Ограничение памяти
64Mb

Сегодня 31 апреля, и в Удотинске по традиции проводятся тараканьи бега. Забеги 
разделены на две категории. Если таракан участвовал в забеге одной из категорий, 
он не может принимать участие в забегах другой категории. Но встречаются нарушители! 
Помогите судьям их выявить и восстановить справедливость.

Есть два списка со стартовыми номерами тараканов. Нужно вывести номера, которые 
встречаются и в первом, и во втором списке. Квадратичный алгоритм не подойдет для 
этой задачи. Тараканы разбегутся, пока алгоритм закончит работу.

### Формат ввода

В первой строке записано число n - длина первого списка. Во второй строке - число 
m - длина второго списка. Оба числа не превосходят 10000 В следующих двух строках 
через пробел могут быть записаны два списка соответствующей длины, состоящие из 
чисел, не превосходящих 10000. 

### Формат вывода

Нужно в строку вывести стартовые номера тараканов в порядке, в котором они 
встречались в первом списке.

</details>

<details>
<summary>E. Пересечение массивов</summary>

[Решение](E.py)

### Ограничение времени
1 секунда
### Ограничение памяти
64Mb

Вам даны два массива чисел длины n и m соответственно. Массивы могут содержать 
повторяющиеся числа и общие элементы. Вам нужно найти пересечение этих двух массивов.

Пересечением будем называть такой массив, в котором число x содержится 
`min(cnt1(x), cnt2(x)) `раз, если `cnti(x)` — число вхождений числа x в массив с номером i. 
Например, если число не встречается в каком-то из массивов, то в пересечение оно входить не будет.

### Формат ввода

В первой строке записано число n —– длина первого массива.

Во второй строке —– число m, длина второго массива.

Оба числа не превосходят 10 000.

В следующих двух строках через пробел записаны два массива соответствующей длины, 
состоящие из целых чисел, не превосходящих 10 000 по модулю.

### Формат вывода

Выведите элементы пересечения в порядке неубывания.

</details>

<details>
<summary>F. Сортировка по четности</summary>

[Решение](F.py)

### Ограничение времени
1 секунда
### Ограничение памяти
64Mb

Кондратий издал новый закон. Во всех списках четные числа должны стоять на четных 
позициях, а нечетные числа - на нечетных. Уже существующие списки придется пересортировать. 
В списках, которые вам достанутся, одинаковое количество четных и нечетных элементов. 
Нужно отсортировать его в соответствии с новым законом. Исходный порядок внутри групп 
четных и нечетных элементов менять нельзя. 

### Формат ввода

В первой строке записано n - целое четное число в диапазоне от 0 до 10000 Далее 
в строку через пробел записаны n чисел, каждое из которых не превосходит 10000 

### Формат вывода

Нужно вывести массив, отсортированный согласно условию.

</details>

<details>
<summary>G. Периметр треугольника</summary>

[Решение](G.py)

### Ограничение времени
0.12 секунд
### Ограничение памяти
64Mb

Перед сном Рита решила поиграть в игру на телефоне. Дан массив целых чисел, в 
котором каждый элемент обозначает длину стороны треугольника. Нужно определить 
максимально возможный периметр треугольника, составленного из сторон с длинами 
из заданного массива. Помогите Рите скорее закончить игру и пойти спать.

Напомним, что из трёх отрезков с длинами `a ≤ b ≤ c` можно составить треугольник, 
если выполнено неравенство треугольника: `c < a + b`

Разберём пример:
даны длины сторон 6, 3, 3, 2. Попробуем в качестве наибольшей стороны выбрать 6. 
Неравенство треугольника не может выполниться, так как остались 3, 3, 2 —– максимальная 
сумма из них равна 6.

Без шестёрки оставшиеся три отрезка уже образуют треугольник со сторонами 3, 3, 2. 
Неравенство выполняется: 3 < 3 + 2. Периметр равен 3 + 3 + 2 = 8.

### Формат ввода

В первой строке записано количество отрезков n, `3≤ n≤ 10000`.

Во второй строке записано n натуральных чисел, не превосходящих 10 000, –— длины отрезков.

### Формат вывода

Нужно вывести одно число —– наибольший периметр треугольника.

</details>

<details>
<summary>H. Клумбы</summary>

[Решение](H.py)

### Ограничение времени
1 секунда
### Ограничение памяти
64Mb

Алла захотела, чтобы у неё под окном были узкие клумбы с тюльпанам. На схеме земельного 
участка клумбы обозначаются просто горизонтальными отрезками, лежащими на одной прямой. 
Для ландшафтных работ было нанято n садовников. Каждый из них обрабатывал какой-то 
отрезок на схеме. Процесс был организован не очень хорошо, иногда один и тот же отрезок
или его часть могли быть обработаны сразу несколькими садовниками. Таким образом, 
отрезки, обрабатываемые двумя разными садовниками, сливаются в один. Непрерывный 
обработанный отрезок затем станет клумбой. Нужно определить границы будущих клумб. 

Рассмотрим примеры.

Пример 1:
Два отрезка `[7, 8]` сливаются в один, но потом их накрывает отрезок `[6, 10]`. Таким 
образом, имеем две клумбы с координатами `[2,3]` и `[6,10]`.

Пример 2
Отрезки `[2,3]`, `[3, 4]` и `[3,4]` сольются в один отрезок `[2,4]`. Отрезок `[5,6]` ни с 
кем не объединяется, добавляем его в ответ. 

### Формат ввода

В первой строке задано количество садовников n. Число садовников не превосходит 100 000.

В следующих n строках через пробел записаны координаты клумб в формате: start end, 
где start —– координата начала, end —– координата конца. Оба числа целые, неотрицательные 
и не превосходят 107. start строго меньше, чем end. 

### Формат вывода

Нужно вывести координаты каждой из получившихся клумб в отдельных строках. Данные 
должны выводится в отсортированном порядке —– сначала клумбы с меньшими координатами, 
затем —– с бОльшими.

</details>

<details>
<summary>I. Гардероб</summary>

[Решение](I.py)

### Ограничение времени
1 секунда
### Ограничение памяти
128Mb


Рита решила оставить у себя одежду только трёх цветов: розового, жёлтого и малинового. 
После того как вещи других расцветок были убраны, Рита захотела отсортировать свой новый 
гардероб по цветам. Сначала должны идти вещи розового цвета, потом —– жёлтого, и в 
конце —– малинового. Помогите Рите справиться с этой задачей.

### Формат ввода

В первой строке задано количество предметов в гардеробе: n –— оно не превосходит 100000. 
Во второй строке даётся массив, в котором указан цвет для каждого предмета. Розовый 
цвет обозначен 0, жёлтый —– 1, малиновый –— 2. 

### Формат вывода

Нужно вывести в строку через пробел цвета предметов в правильном порядке.

</details>

<details>
<summary>J. Относительная сортировка</summary>

[Решение](J.py)

### Ограничение времени
1 секунда
### Ограничение памяти
 64Mb

Кондратий ввел новый метод сортировки - Относительная сортировка.
Идея метода следующая. С помощью образца - массива уникальных чисел, задается порядок. 
В соответствии с этим порядком и должны сортироваться числа.
Но метод еще требует доработки. Пока не известно, как сортировать числа, которые не 
входят в образец. Так что такие числа нужно выводить в конце в соответствии со стандартной 
сортировкой. 

### Формат ввода

В первой строке задано количество чисел, которые нужно отсортировать, n. Оно не превосходит 1500.
В следующей строке через пробел заданы n чисел, каждое из которых не превосходит 1000.
В третей строке задана длина образца m. Это число не превосходит 1500.
В следующей строке записан образец. Он состоит из чисел, не превосходящих 1000.
Гарантируется, что среди чисел, которые нужно отсортировать, присутствуют все числа из образца. 

### Формат вывода

Выведите в строку через пробел числа, отсортированные Относительной сортировкой.

</details>